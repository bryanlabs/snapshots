import { NextRequest, NextResponse } from 'next/server';
import { RateLimiterMemory } from 'rate-limiter-flexible';

// Mock dependencies before imports
jest.mock('rate-limiter-flexible');
jest.mock('@/lib/monitoring/metrics');
jest.mock('@/auth', () => ({
  auth: jest.fn(),
}));
jest.mock('next/headers', () => ({
  cookies: jest.fn().mockResolvedValue({
    get: jest.fn(),
    set: jest.fn(),
    delete: jest.fn(),
  }),
}));

// Import after mocks
import { rateLimitMiddleware, withRateLimit } from '@/lib/middleware/rateLimiter';
import * as metrics from '@/lib/monitoring/metrics';
import { auth } from '@/auth';

describe('Rate Limiter', () => {
  let mockConsume: jest.Mock;
  let mockTrackRateLimitHit: jest.Mock;
  let mockAuth: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();
    
    // Setup mocks
    mockConsume = jest.fn().mockResolvedValue(undefined);
    mockTrackRateLimitHit = jest.fn();
    mockAuth = jest.fn().mockResolvedValue(null);
    
    // Mock RateLimiterMemory constructor
    (RateLimiterMemory as jest.Mock).mockImplementation(() => ({
      consume: mockConsume,
      points: 100,
    }));
    
    (metrics.trackRateLimitHit as jest.Mock) = mockTrackRateLimitHit;
    (auth as jest.Mock) = mockAuth;
  });

  describe('rateLimitMiddleware', () => {
    it('should allow request when under rate limit', async () => {
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitMiddleware(request);
      
      expect(response).toBeNull();
      expect(mockConsume).toHaveBeenCalledWith('anonymous');
    });

    it('should use user ID for authenticated users', async () => {
      mockAuth.mockResolvedValue({
        user: {
          id: 'user123',
          email: 'user@example.com',
          tier: 'free',
        },
      });
      
      const request = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimitMiddleware(request);
      
      expect(mockConsume).toHaveBeenCalledWith('user123');
    });

    it('should block request when rate limit exceeded', async () => {
      const rateLimitError = {
        msBeforeNext: 60000,
        remainingPoints: 0,
      };
      mockConsume.mockRejectedValue(rateLimitError);
      
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitMiddleware(request);
      
      expect(response).not.toBeNull();
      expect(response?.status).toBe(429);
      
      const data = await response?.json();
      expect(data.error).toBe('Too many requests');
      expect(data.retryAfter).toBe(60);
      expect(data.message).toBe('Please try again in 60 seconds');
    });

    it('should set rate limit headers', async () => {
      const rateLimitError = {
        msBeforeNext: 30000,
        remainingPoints: 5,
      };
      mockConsume.mockRejectedValue(rateLimitError);
      
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitMiddleware(request);
      
      expect(response?.headers.get('Retry-After')).toBe('30');
      expect(response?.headers.get('X-RateLimit-Limit')).toBe('100');
      expect(response?.headers.get('X-RateLimit-Remaining')).toBe('5');
      expect(response?.headers.get('X-RateLimit-Reset')).toBeTruthy();
    });

    it('should track rate limit hits', async () => {
      mockConsume.mockRejectedValue({ msBeforeNext: 60000 });
      
      const request = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimitMiddleware(request);
      
      expect(mockTrackRateLimitHit).toHaveBeenCalledWith('/api/test', 'free');
    });

    it('should use premium tier for premium users', async () => {
      mockAuth.mockResolvedValue({
        user: {
          id: 'premium-user',
          email: 'premium@example.com',
          tier: 'premium',
        },
      });
      
      const request = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimitMiddleware(request, 'general');
      
      // Verify premium rate limiter was created (200 points instead of 100)
      const rateLimiterCalls = (RateLimiterMemory as jest.Mock).mock.calls;
      const premiumLimiter = rateLimiterCalls.find(call => call[0].points === 200);
      expect(premiumLimiter).toBeDefined();
    });

    it('should use different rate limiters for different types', async () => {
      const request = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimitMiddleware(request, 'download');
      await rateLimitMiddleware(request, 'auth');
      await rateLimitMiddleware(request, 'general');
      
      const rateLimiterCalls = (RateLimiterMemory as jest.Mock).mock.calls;
      
      // Verify different configurations were used
      const downloadLimiter = rateLimiterCalls.find(call => call[0].points === 10);
      const authLimiter = rateLimiterCalls.find(call => call[0].points === 5);
      const generalLimiter = rateLimiterCalls.find(call => call[0].points === 100);
      
      expect(downloadLimiter).toBeDefined();
      expect(authLimiter).toBeDefined();
      expect(generalLimiter).toBeDefined();
    });

    it('should handle rate limiter errors gracefully', async () => {
      mockConsume.mockRejectedValue(new Error('Rate limiter failed'));
      
      const consoleError = jest.spyOn(console, 'error').mockImplementation();
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitMiddleware(request);
      
      expect(response).toBeNull(); // Allow request on error
      expect(consoleError).toHaveBeenCalledWith('Rate limiter error:', expect.any(Error));
      
      consoleError.mockRestore();
    });

    it('should use IP fallback when no user session', async () => {
      const request = new NextRequest('http://localhost:3000/api/test', {
        headers: {
          'x-forwarded-for': '192.168.1.1',
        },
      });
      
      await rateLimitMiddleware(request);
      
      expect(mockConsume).toHaveBeenCalledWith('192.168.1.1');
    });

    it('should use x-real-ip header as fallback', async () => {
      const request = new NextRequest('http://localhost:3000/api/test', {
        headers: {
          'x-real-ip': '10.0.0.1',
        },
      });
      
      await rateLimitMiddleware(request);
      
      expect(mockConsume).toHaveBeenCalledWith('10.0.0.1');
    });
  });

  describe('withRateLimit', () => {
    it('should wrap handler and apply rate limiting', async () => {
      const mockHandler = jest.fn().mockResolvedValue(
        NextResponse.json({ success: true })
      );
      
      const rateLimitedHandler = withRateLimit(mockHandler, 'download');
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitedHandler(request);
      
      expect(mockConsume).toHaveBeenCalled();
      expect(mockHandler).toHaveBeenCalledWith(request);
      
      const data = await response.json();
      expect(data.success).toBe(true);
    });

    it('should return rate limit response when limit exceeded', async () => {
      mockConsume.mockRejectedValue({ msBeforeNext: 60000 });
      
      const mockHandler = jest.fn();
      const rateLimitedHandler = withRateLimit(mockHandler, 'auth');
      const request = new NextRequest('http://localhost:3000/api/test');
      
      const response = await rateLimitedHandler(request);
      
      expect(response.status).toBe(429);
      expect(mockHandler).not.toHaveBeenCalled();
    });

    it('should use default rate limit type', async () => {
      const mockHandler = jest.fn().mockResolvedValue(
        NextResponse.json({ success: true })
      );
      
      const rateLimitedHandler = withRateLimit(mockHandler);
      const request = new NextRequest('http://localhost:3000/api/test');
      
      await rateLimitedHandler(request);
      
      // Should use general rate limiter (100 points)
      const rateLimiterCalls = (RateLimiterMemory as jest.Mock).mock.calls;
      const generalLimiter = rateLimiterCalls.find(call => call[0].points === 100);
      expect(generalLimiter).toBeDefined();
    });
  });
});